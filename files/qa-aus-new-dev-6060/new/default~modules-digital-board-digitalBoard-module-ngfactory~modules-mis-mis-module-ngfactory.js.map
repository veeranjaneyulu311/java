{"version":3,"sources":["webpack:///./node_modules/@tweenjs/tween.js/src/Tween.js","webpack:///./node_modules/ngx-virtual-scroller/dist/virtual-scroller.js"],"names":[],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH,EAAE;;AAEF;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;;AAEvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC;AACvC;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA,gEAAgE,sBAAsB;AACtF;AACA;;AAEA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,IAAI;;AAEJ;;AAEA;AACA;;AAEA,kEAAkE,sBAAsB;AACxF;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,QAAQ;AACzB;AACA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;AACA;;AAEA;;AAEA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,KAAK,IAA0C;;AAE/C;AACA,EAAE,iCAAO,EAAE,mCAAE;AACb;AACA,GAAG;AAAA,oGAAC;;AAEJ,EAAE,MAAM,EAUN;;AAEF,CAAC;;;;;;;;;;;;;ACr6BY;AACb,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,iEAAe;AACpC,aAAa,mBAAO,CAAC,iEAAe;AACpC,eAAe,mBAAO,CAAC,uEAAiB;AACxC,eAAe,mBAAO,CAAC,uEAAiB;AACxC,YAAY,mBAAO,CAAC,wEAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wBAAwB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE,0CAA0C,sBAAsB;AAChE,+CAA+C,mCAAmC;AAClF,oDAAoD,wCAAwC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE,0CAA0C,sBAAsB;AAChE,+CAA+C,mCAAmC;AAClF,oDAAoD,wCAAwC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE,0CAA0C,sBAAsB;AAChE,+CAA+C,mCAAmC;AAClF,oDAAoD,wCAAwC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mCAAmC;AAClF,oDAAoD,wCAAwC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,iBAAiB,iCAAiC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sCAAsC;AACxF,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,mCAAmC,EAAE;AACzH;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yEAAyE;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,uCAAuC,2BAA2B,qBAAqB,0CAA0C,OAAO,qCAAqC,4BAA4B,yBAAyB,KAAK,+BAA+B,yBAAyB,4BAA4B,KAAK,+BAA+B,eAAe,gBAAgB,oBAAoB,qBAAqB,yBAAyB,0BAA0B,2BAA2B,OAAO,yCAAyC,6BAA6B,KAAK,0BAA0B,0BAA0B,KAAK,8CAA8C,oBAAoB,KAAK,4DAA4D,qBAAqB,mBAAmB,2BAA2B,KAAK,0BAA0B,mBAAmB,mBAAmB,OAAO,6CAA6C,qBAAqB,OAAO;AAC39B,aAAa,IAAI;AACjB;AACA;AACA,uDAAuD;AACvD,KAAK,2BAA2B;AAChC,KAAK,0BAA0B;AAC/B,KAAK,uBAAuB;AAC5B,KAAK,kCAAkC;AACvC,KAAK,6BAA6B,mDAAmD,IAAI;AACzF,KAAK,gCAAgC,wBAAwB,GAAG,uEAAuE,IAAI;AAC3I,KAAK,gCAAgC,wBAAwB,GAAG,qEAAqE,IAAI;AACzI,KAAK,gCAAgC,wBAAwB,GAAG,sEAAsE,IAAI;AAC1I,KAAK,gCAAgC,wBAAwB,GAAG,iEAAiE,IAAI;AACrI,KAAK,gCAAgC,wBAAwB,GAAG,kEAAkE,IAAI;AACtI,KAAK,gCAAgC,wBAAwB,GAAG,sEAAsE,IAAI;AAC1I,KAAK,gCAAgC,wBAAwB,GAAG,+EAA+E,IAAI;AACnJ,KAAK,gCAAgC,wBAAwB,GAAG,oFAAoF,IAAI;AACxJ,KAAK,gCAAgC,wBAAwB,GAAG,+DAA+D,IAAI;AACnI,EAAE;AACF;AACA,0CAA0C,qBAAqB;AAC/D,oCAAoC,qBAAqB;AACzD,qCAAqC,qBAAqB;AAC1D,2CAA2C,qBAAqB;AAChE,sBAAsB,qBAAqB;AAC3C,wBAAwB,qBAAqB;AAC7C,yBAAyB,qBAAqB;AAC9C,oBAAoB,qBAAqB;AACzC,qBAAqB,qBAAqB;AAC1C,uBAAuB,qBAAqB;AAC5C,wBAAwB,qBAAqB;AAC7C,0BAA0B,qBAAqB;AAC/C,2BAA2B,qBAAqB;AAChD,sBAAsB,qBAAqB;AAC3C,6BAA6B,qBAAqB;AAClD,sCAAsC,qBAAqB;AAC3D,8BAA8B,qBAAqB;AACnD,4BAA4B,qBAAqB;AACjD,6BAA6B,qBAAqB;AAClD,eAAe,qBAAqB;AACpC,sBAAsB,qBAAqB;AAC3C,oBAAoB,qBAAqB;AACzC,sBAAsB,qBAAqB;AAC3C,gBAAgB,sBAAsB;AACtC,kBAAkB,sBAAsB;AACxC,gBAAgB,sBAAsB;AACtC,kBAAkB,sBAAsB;AACxC,eAAe,sBAAsB;AACrC,iBAAiB,sBAAsB;AACvC,aAAa,sBAAsB;AACnC,eAAe,sBAAsB;AACrC,2BAA2B,4CAA4C,0BAA0B,IAAI;AACrG,oCAAoC,qDAAqD,0BAA0B,IAAI;AACvH,0BAA0B,8CAA8C,0BAA0B,IAAI;AACtG,6BAA6B,iDAAiD,0BAA0B,IAAI;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,KAAK;AACL;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA,oDAAoD,WAAW;AAC/D;AACA,4C","file":"default~modules-digital-board-digitalBoard-module-ngfactory~modules-mis-mis-module-ngfactory.js","sourcesContent":["/**\n * Tween.js - Licensed under the MIT license\n * https://github.com/tweenjs/tween.js\n * ----------------------------------------------\n *\n * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.\n * Thank you all, you're awesome!\n */\n\n\nvar _Group = function () {\n\tthis._tweens = {};\n\tthis._tweensAddedDuringUpdate = {};\n};\n\n_Group.prototype = {\n\tgetAll: function () {\n\n\t\treturn Object.keys(this._tweens).map(function (tweenId) {\n\t\t\treturn this._tweens[tweenId];\n\t\t}.bind(this));\n\n\t},\n\n\tremoveAll: function () {\n\n\t\tthis._tweens = {};\n\n\t},\n\n\tadd: function (tween) {\n\n\t\tthis._tweens[tween.getId()] = tween;\n\t\tthis._tweensAddedDuringUpdate[tween.getId()] = tween;\n\n\t},\n\n\tremove: function (tween) {\n\n\t\tdelete this._tweens[tween.getId()];\n\t\tdelete this._tweensAddedDuringUpdate[tween.getId()];\n\n\t},\n\n\tupdate: function (time, preserve) {\n\n\t\tvar tweenIds = Object.keys(this._tweens);\n\n\t\tif (tweenIds.length === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\ttime = time !== undefined ? time : TWEEN.now();\n\n\t\t// Tweens are updated in \"batches\". If you add a new tween during an update, then the\n\t\t// new tween will be updated in the next batch.\n\t\t// If you remove a tween during an update, it may or may not be updated. However,\n\t\t// if the removed tween was added during the current batch, then it will not be updated.\n\t\twhile (tweenIds.length > 0) {\n\t\t\tthis._tweensAddedDuringUpdate = {};\n\n\t\t\tfor (var i = 0; i < tweenIds.length; i++) {\n\n\t\t\t\tvar tween = this._tweens[tweenIds[i]];\n\n\t\t\t\tif (tween && tween.update(time) === false) {\n\t\t\t\t\ttween._isPlaying = false;\n\n\t\t\t\t\tif (!preserve) {\n\t\t\t\t\t\tdelete this._tweens[tweenIds[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttweenIds = Object.keys(this._tweensAddedDuringUpdate);\n\t\t}\n\n\t\treturn true;\n\n\t}\n};\n\nvar TWEEN = new _Group();\n\nTWEEN.Group = _Group;\nTWEEN._nextId = 0;\nTWEEN.nextId = function () {\n\treturn TWEEN._nextId++;\n};\n\n\n// Include a performance.now polyfill.\n// In node.js, use process.hrtime.\nif (typeof (self) === 'undefined' && typeof (process) !== 'undefined' && process.hrtime) {\n\tTWEEN.now = function () {\n\t\tvar time = process.hrtime();\n\n\t\t// Convert [seconds, nanoseconds] to milliseconds.\n\t\treturn time[0] * 1000 + time[1] / 1000000;\n\t};\n}\n// In a browser, use self.performance.now if it is available.\nelse if (typeof (self) !== 'undefined' &&\n         self.performance !== undefined &&\n\t\t self.performance.now !== undefined) {\n\t// This must be bound, because directly assigning this function\n\t// leads to an invocation exception in Chrome.\n\tTWEEN.now = self.performance.now.bind(self.performance);\n}\n// Use Date.now if it is available.\nelse if (Date.now !== undefined) {\n\tTWEEN.now = Date.now;\n}\n// Otherwise, use 'new Date().getTime()'.\nelse {\n\tTWEEN.now = function () {\n\t\treturn new Date().getTime();\n\t};\n}\n\n\nTWEEN.Tween = function (object, group) {\n\tthis._object = object;\n\tthis._valuesStart = {};\n\tthis._valuesEnd = {};\n\tthis._valuesStartRepeat = {};\n\tthis._duration = 1000;\n\tthis._repeat = 0;\n\tthis._repeatDelayTime = undefined;\n\tthis._yoyo = false;\n\tthis._isPlaying = false;\n\tthis._reversed = false;\n\tthis._delayTime = 0;\n\tthis._startTime = null;\n\tthis._easingFunction = TWEEN.Easing.Linear.None;\n\tthis._interpolationFunction = TWEEN.Interpolation.Linear;\n\tthis._chainedTweens = [];\n\tthis._onStartCallback = null;\n\tthis._onStartCallbackFired = false;\n\tthis._onUpdateCallback = null;\n\tthis._onRepeatCallback = null;\n\tthis._onCompleteCallback = null;\n\tthis._onStopCallback = null;\n\tthis._group = group || TWEEN;\n\tthis._id = TWEEN.nextId();\n\n};\n\nTWEEN.Tween.prototype = {\n\tgetId: function () {\n\t\treturn this._id;\n\t},\n\n\tisPlaying: function () {\n\t\treturn this._isPlaying;\n\t},\n\n\tto: function (properties, duration) {\n\n\t\tthis._valuesEnd = Object.create(properties);\n\n\t\tif (duration !== undefined) {\n\t\t\tthis._duration = duration;\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tduration: function duration(d) {\n\t\tthis._duration = d;\n\t\treturn this;\n\t},\n\n\tstart: function (time) {\n\n\t\tthis._group.add(this);\n\n\t\tthis._isPlaying = true;\n\n\t\tthis._onStartCallbackFired = false;\n\n\t\tthis._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();\n\t\tthis._startTime += this._delayTime;\n\n\t\tfor (var property in this._valuesEnd) {\n\n\t\t\t// Check if an Array was provided as property value\n\t\t\tif (this._valuesEnd[property] instanceof Array) {\n\n\t\t\t\tif (this._valuesEnd[property].length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Create a local copy of the Array with the start value at the front\n\t\t\t\tthis._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);\n\n\t\t\t}\n\n\t\t\t// If `to()` specifies a property that doesn't exist in the source object,\n\t\t\t// we should not set that property in the object\n\t\t\tif (this._object[property] === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Save the starting value.\n\t\t\tthis._valuesStart[property] = this._object[property];\n\n\t\t\tif ((this._valuesStart[property] instanceof Array) === false) {\n\t\t\t\tthis._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings\n\t\t\t}\n\n\t\t\tthis._valuesStartRepeat[property] = this._valuesStart[property] || 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tstop: function () {\n\n\t\tif (!this._isPlaying) {\n\t\t\treturn this;\n\t\t}\n\n\t\tthis._group.remove(this);\n\t\tthis._isPlaying = false;\n\n\t\tif (this._onStopCallback !== null) {\n\t\t\tthis._onStopCallback(this._object);\n\t\t}\n\n\t\tthis.stopChainedTweens();\n\t\treturn this;\n\n\t},\n\n\tend: function () {\n\n\t\tthis.update(Infinity);\n\t\treturn this;\n\n\t},\n\n\tstopChainedTweens: function () {\n\n\t\tfor (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\tthis._chainedTweens[i].stop();\n\t\t}\n\n\t},\n\n\tgroup: function (group) {\n\t\tthis._group = group;\n\t\treturn this;\n\t},\n\n\tdelay: function (amount) {\n\n\t\tthis._delayTime = amount;\n\t\treturn this;\n\n\t},\n\n\trepeat: function (times) {\n\n\t\tthis._repeat = times;\n\t\treturn this;\n\n\t},\n\n\trepeatDelay: function (amount) {\n\n\t\tthis._repeatDelayTime = amount;\n\t\treturn this;\n\n\t},\n\n\tyoyo: function (yoyo) {\n\n\t\tthis._yoyo = yoyo;\n\t\treturn this;\n\n\t},\n\n\teasing: function (easingFunction) {\n\n\t\tthis._easingFunction = easingFunction;\n\t\treturn this;\n\n\t},\n\n\tinterpolation: function (interpolationFunction) {\n\n\t\tthis._interpolationFunction = interpolationFunction;\n\t\treturn this;\n\n\t},\n\n\tchain: function () {\n\n\t\tthis._chainedTweens = arguments;\n\t\treturn this;\n\n\t},\n\n\tonStart: function (callback) {\n\n\t\tthis._onStartCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonUpdate: function (callback) {\n\n\t\tthis._onUpdateCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonRepeat: function onRepeat(callback) {\n\n\t\tthis._onRepeatCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonComplete: function (callback) {\n\n\t\tthis._onCompleteCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tonStop: function (callback) {\n\n\t\tthis._onStopCallback = callback;\n\t\treturn this;\n\n\t},\n\n\tupdate: function (time) {\n\n\t\tvar property;\n\t\tvar elapsed;\n\t\tvar value;\n\n\t\tif (time < this._startTime) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (this._onStartCallbackFired === false) {\n\n\t\t\tif (this._onStartCallback !== null) {\n\t\t\t\tthis._onStartCallback(this._object);\n\t\t\t}\n\n\t\t\tthis._onStartCallbackFired = true;\n\t\t}\n\n\t\telapsed = (time - this._startTime) / this._duration;\n\t\telapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;\n\n\t\tvalue = this._easingFunction(elapsed);\n\n\t\tfor (property in this._valuesEnd) {\n\n\t\t\t// Don't update properties that do not exist in the source object\n\t\t\tif (this._valuesStart[property] === undefined) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar start = this._valuesStart[property] || 0;\n\t\t\tvar end = this._valuesEnd[property];\n\n\t\t\tif (end instanceof Array) {\n\n\t\t\t\tthis._object[property] = this._interpolationFunction(end, value);\n\n\t\t\t} else {\n\n\t\t\t\t// Parses relative end values with start as base (e.g.: +10, -3)\n\t\t\t\tif (typeof (end) === 'string') {\n\n\t\t\t\t\tif (end.charAt(0) === '+' || end.charAt(0) === '-') {\n\t\t\t\t\t\tend = start + parseFloat(end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tend = parseFloat(end);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Protect against non numeric properties.\n\t\t\t\tif (typeof (end) === 'number') {\n\t\t\t\t\tthis._object[property] = start + (end - start) * value;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif (this._onUpdateCallback !== null) {\n\t\t\tthis._onUpdateCallback(this._object, elapsed);\n\t\t}\n\n\t\tif (elapsed === 1) {\n\n\t\t\tif (this._repeat > 0) {\n\n\t\t\t\tif (isFinite(this._repeat)) {\n\t\t\t\t\tthis._repeat--;\n\t\t\t\t}\n\n\t\t\t\t// Reassign starting values, restart by making startTime = now\n\t\t\t\tfor (property in this._valuesStartRepeat) {\n\n\t\t\t\t\tif (typeof (this._valuesEnd[property]) === 'string') {\n\t\t\t\t\t\tthis._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this._yoyo) {\n\t\t\t\t\t\tvar tmp = this._valuesStartRepeat[property];\n\n\t\t\t\t\t\tthis._valuesStartRepeat[property] = this._valuesEnd[property];\n\t\t\t\t\t\tthis._valuesEnd[property] = tmp;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._valuesStart[property] = this._valuesStartRepeat[property];\n\n\t\t\t\t}\n\n\t\t\t\tif (this._yoyo) {\n\t\t\t\t\tthis._reversed = !this._reversed;\n\t\t\t\t}\n\n\t\t\t\tif (this._repeatDelayTime !== undefined) {\n\t\t\t\t\tthis._startTime = time + this._repeatDelayTime;\n\t\t\t\t} else {\n\t\t\t\t\tthis._startTime = time + this._delayTime;\n\t\t\t\t}\n\n\t\t\t\tif (this._onRepeatCallback !== null) {\n\t\t\t\t\tthis._onRepeatCallback(this._object);\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\tif (this._onCompleteCallback !== null) {\n\n\t\t\t\t\tthis._onCompleteCallback(this._object);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {\n\t\t\t\t\t// Make the chained tweens start exactly at the time they should,\n\t\t\t\t\t// even if the `update()` method was called way past the duration of the tween\n\t\t\t\t\tthis._chainedTweens[i].start(this._startTime + this._duration);\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n};\n\n\nTWEEN.Easing = {\n\n\tLinear: {\n\n\t\tNone: function (k) {\n\n\t\t\treturn k;\n\n\t\t}\n\n\t},\n\n\tQuadratic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn k * (2 - k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * (--k * (k - 2) - 1);\n\n\t\t}\n\n\t},\n\n\tCubic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn --k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tQuartic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn 1 - (--k * k * k * k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn - 0.5 * ((k -= 2) * k * k * k - 2);\n\n\t\t}\n\n\t},\n\n\tQuintic: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k * k * k * k * k;\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn --k * k * k * k * k + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k * k;\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * k * k * k + 2);\n\n\t\t}\n\n\t},\n\n\tSinusoidal: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - Math.cos(k * Math.PI / 2);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn Math.sin(k * Math.PI / 2);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\treturn 0.5 * (1 - Math.cos(Math.PI * k));\n\n\t\t}\n\n\t},\n\n\tExponential: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn k === 0 ? 0 : Math.pow(1024, k - 1);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * Math.pow(1024, k - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);\n\n\t\t}\n\n\t},\n\n\tCircular: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - Math.sqrt(1 - k * k);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\treturn Math.sqrt(1 - (--k * k));\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn - 0.5 * (Math.sqrt(1 - k * k) - 1);\n\t\t\t}\n\n\t\t\treturn 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\n\t\t}\n\n\t},\n\n\tElastic: {\n\n\t\tIn: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\treturn Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tk *= 2;\n\n\t\t\tif (k < 1) {\n\t\t\t\treturn -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\t\t\t}\n\n\t\t\treturn 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n\n\t\t}\n\n\t},\n\n\tBack: {\n\n\t\tIn: function (k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn k * k * ((s + 1) * k - s);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tvar s = 1.70158;\n\n\t\t\treturn --k * k * ((s + 1) * k + s) + 1;\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tvar s = 1.70158 * 1.525;\n\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * (k * k * ((s + 1) * k - s));\n\t\t\t}\n\n\t\t\treturn 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\n\t\t}\n\n\t},\n\n\tBounce: {\n\n\t\tIn: function (k) {\n\n\t\t\treturn 1 - TWEEN.Easing.Bounce.Out(1 - k);\n\n\t\t},\n\n\t\tOut: function (k) {\n\n\t\t\tif (k < (1 / 2.75)) {\n\t\t\t\treturn 7.5625 * k * k;\n\t\t\t} else if (k < (2 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t\t\t} else if (k < (2.5 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t\t\t} else {\n\t\t\t\treturn 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t\t\t}\n\n\t\t},\n\n\t\tInOut: function (k) {\n\n\t\t\tif (k < 0.5) {\n\t\t\t\treturn TWEEN.Easing.Bounce.In(k * 2) * 0.5;\n\t\t\t}\n\n\t\t\treturn TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n\n\t\t}\n\n\t}\n\n};\n\nTWEEN.Interpolation = {\n\n\tLinear: function (v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.Linear;\n\n\t\tif (k < 0) {\n\t\t\treturn fn(v[0], v[1], f);\n\t\t}\n\n\t\tif (k > 1) {\n\t\t\treturn fn(v[m], v[m - 1], m - f);\n\t\t}\n\n\t\treturn fn(v[i], v[i + 1 > m ? m : i + 1], f - i);\n\n\t},\n\n\tBezier: function (v, k) {\n\n\t\tvar b = 0;\n\t\tvar n = v.length - 1;\n\t\tvar pw = Math.pow;\n\t\tvar bn = TWEEN.Interpolation.Utils.Bernstein;\n\n\t\tfor (var i = 0; i <= n; i++) {\n\t\t\tb += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);\n\t\t}\n\n\t\treturn b;\n\n\t},\n\n\tCatmullRom: function (v, k) {\n\n\t\tvar m = v.length - 1;\n\t\tvar f = m * k;\n\t\tvar i = Math.floor(f);\n\t\tvar fn = TWEEN.Interpolation.Utils.CatmullRom;\n\n\t\tif (v[0] === v[m]) {\n\n\t\t\tif (k < 0) {\n\t\t\t\ti = Math.floor(f = m * (1 + k));\n\t\t\t}\n\n\t\t\treturn fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);\n\n\t\t} else {\n\n\t\t\tif (k < 0) {\n\t\t\t\treturn v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);\n\t\t\t}\n\n\t\t\tif (k > 1) {\n\t\t\t\treturn v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);\n\t\t\t}\n\n\t\t\treturn fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);\n\n\t\t}\n\n\t},\n\n\tUtils: {\n\n\t\tLinear: function (p0, p1, t) {\n\n\t\t\treturn (p1 - p0) * t + p0;\n\n\t\t},\n\n\t\tBernstein: function (n, i) {\n\n\t\t\tvar fc = TWEEN.Interpolation.Utils.Factorial;\n\n\t\t\treturn fc(n) / fc(i) / fc(n - i);\n\n\t\t},\n\n\t\tFactorial: (function () {\n\n\t\t\tvar a = [1];\n\n\t\t\treturn function (n) {\n\n\t\t\t\tvar s = 1;\n\n\t\t\t\tif (a[n]) {\n\t\t\t\t\treturn a[n];\n\t\t\t\t}\n\n\t\t\t\tfor (var i = n; i > 1; i--) {\n\t\t\t\t\ts *= i;\n\t\t\t\t}\n\n\t\t\t\ta[n] = s;\n\t\t\t\treturn s;\n\n\t\t\t};\n\n\t\t})(),\n\n\t\tCatmullRom: function (p0, p1, p2, p3, t) {\n\n\t\t\tvar v0 = (p2 - p0) * 0.5;\n\t\t\tvar v1 = (p3 - p1) * 0.5;\n\t\t\tvar t2 = t * t;\n\t\t\tvar t3 = t * t2;\n\n\t\t\treturn (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n\n\t\t}\n\n\t}\n\n};\n\n// UMD (Universal Module Definition)\n(function (root) {\n\n\tif (typeof define === 'function' && define.amd) {\n\n\t\t// AMD\n\t\tdefine([], function () {\n\t\t\treturn TWEEN;\n\t\t});\n\n\t} else if (typeof module !== 'undefined' && typeof exports === 'object') {\n\n\t\t// Node.js\n\t\tmodule.exports = TWEEN;\n\n\t} else if (root !== undefined) {\n\n\t\t// Global variable\n\t\troot.TWEEN = TWEEN;\n\n\t}\n\n})(this);\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar core_1 = require(\"@angular/core\");\r\nvar core_2 = require(\"@angular/core\");\r\nvar common_1 = require(\"@angular/common\");\r\nvar common_2 = require(\"@angular/common\");\r\nvar tween = require(\"@tweenjs/tween.js\");\r\nvar VirtualScrollerComponent = (function () {\r\n    function VirtualScrollerComponent(element, renderer, zone, changeDetectorRef, platformId, scrollThrottlingTime, scrollDebounceTime, scrollAnimationTime, scrollbarWidth, scrollbarHeight, checkResizeInterval, resizeBypassRefreshThreshold, modifyOverflowStyleOfParentScroll, stripedTable) {\r\n        this.element = element;\r\n        this.renderer = renderer;\r\n        this.zone = zone;\r\n        this.changeDetectorRef = changeDetectorRef;\r\n        this.window = window;\r\n        this.executeRefreshOutsideAngularZone = false;\r\n        this._enableUnequalChildrenSizes = false;\r\n        this.useMarginInsteadOfTranslate = false;\r\n        this.ssrViewportWidth = 1920;\r\n        this.ssrViewportHeight = 1080;\r\n        this._bufferAmount = 0;\r\n        this.scrollAnimationTime = 750;\r\n        this.resizeBypassRefreshThreshold = 5;\r\n        this._checkResizeInterval = 1000;\r\n        this._items = [];\r\n        this.compareItems = function (item1, item2) { return item1 === item2; };\r\n        this.update = new core_1.EventEmitter();\r\n        this.vsUpdate = new core_1.EventEmitter();\r\n        this.change = new core_1.EventEmitter();\r\n        this.vsChange = new core_1.EventEmitter();\r\n        this.start = new core_1.EventEmitter();\r\n        this.vsStart = new core_1.EventEmitter();\r\n        this.end = new core_1.EventEmitter();\r\n        this.vsEnd = new core_1.EventEmitter();\r\n        this.calculatedScrollbarWidth = 0;\r\n        this.calculatedScrollbarHeight = 0;\r\n        this.padding = 0;\r\n        this.previousViewPort = {};\r\n        this.cachedPageSize = 0;\r\n        this.previousScrollNumberElements = 0;\r\n        this.isAngularUniversalSSR = common_1.isPlatformServer(platformId);\r\n        this.scrollThrottlingTime = typeof (scrollThrottlingTime) === 'number' ? scrollThrottlingTime : 0;\r\n        this.scrollDebounceTime = typeof (scrollDebounceTime) === 'number' ? scrollDebounceTime : 0;\r\n        if (typeof (scrollAnimationTime) === 'number') {\r\n            this.scrollAnimationTime = scrollAnimationTime;\r\n        }\r\n        if (typeof (scrollbarWidth) === 'number') {\r\n            this.scrollbarWidth = scrollbarWidth;\r\n        }\r\n        if (typeof (scrollbarHeight) === 'number') {\r\n            this.scrollbarHeight = scrollbarHeight;\r\n        }\r\n        if (typeof (checkResizeInterval) === 'number') {\r\n            this.checkResizeInterval = checkResizeInterval;\r\n        }\r\n        if (typeof (resizeBypassRefreshThreshold) === 'number') {\r\n            this.resizeBypassRefreshThreshold = resizeBypassRefreshThreshold;\r\n        }\r\n        this.modifyOverflowStyleOfParentScroll = true;\r\n        if (typeof (modifyOverflowStyleOfParentScroll) === 'boolean') {\r\n            this.modifyOverflowStyleOfParentScroll = modifyOverflowStyleOfParentScroll;\r\n        }\r\n        this.stripedTable = false;\r\n        if (typeof (stripedTable) === 'boolean') {\r\n            this.stripedTable = stripedTable;\r\n        }\r\n        this.horizontal = false;\r\n        this.resetWrapGroupDimensions();\r\n    }\r\n    Object.defineProperty(VirtualScrollerComponent.prototype, \"viewPortInfo\", {\r\n        get: function () {\r\n            var pageInfo = this.previousViewPort || {};\r\n            return {\r\n                startIndex: pageInfo.startIndex || 0,\r\n                endIndex: pageInfo.endIndex || 0,\r\n                scrollStartPosition: pageInfo.scrollStartPosition || 0,\r\n                scrollEndPosition: pageInfo.scrollEndPosition || 0,\r\n                maxScrollPosition: pageInfo.maxScrollPosition || 0,\r\n                startIndexWithBuffer: pageInfo.startIndexWithBuffer || 0,\r\n                endIndexWithBuffer: pageInfo.endIndexWithBuffer || 0\r\n            };\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VirtualScrollerComponent.prototype, \"enableUnequalChildrenSizes\", {\r\n        get: function () {\r\n            return this._enableUnequalChildrenSizes;\r\n        },\r\n        set: function (value) {\r\n            if (this._enableUnequalChildrenSizes === value) {\r\n                return;\r\n            }\r\n            this._enableUnequalChildrenSizes = value;\r\n            this.minMeasuredChildWidth = undefined;\r\n            this.minMeasuredChildHeight = undefined;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VirtualScrollerComponent.prototype, \"bufferAmount\", {\r\n        get: function () {\r\n            if (typeof (this._bufferAmount) === 'number' && this._bufferAmount >= 0) {\r\n                return this._bufferAmount;\r\n            }\r\n            else {\r\n                return this.enableUnequalChildrenSizes ? 5 : 0;\r\n            }\r\n        },\r\n        set: function (value) {\r\n            this._bufferAmount = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VirtualScrollerComponent.prototype, \"scrollThrottlingTime\", {\r\n        get: function () {\r\n            return this._scrollThrottlingTime;\r\n        },\r\n        set: function (value) {\r\n            this._scrollThrottlingTime = value;\r\n            this.updateOnScrollFunction();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VirtualScrollerComponent.prototype, \"scrollDebounceTime\", {\r\n        get: function () {\r\n            return this._scrollDebounceTime;\r\n        },\r\n        set: function (value) {\r\n            this._scrollDebounceTime = value;\r\n            this.updateOnScrollFunction();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    VirtualScrollerComponent.prototype.updateOnScrollFunction = function () {\r\n        var _this = this;\r\n        if (this.scrollDebounceTime) {\r\n            this.onScroll = this.debounce(function () {\r\n                _this.refresh_internal(false);\r\n            }, this.scrollDebounceTime);\r\n        }\r\n        else if (this.scrollThrottlingTime) {\r\n            this.onScroll = this.throttleTrailing(function () {\r\n                _this.refresh_internal(false);\r\n            }, this.scrollThrottlingTime);\r\n        }\r\n        else {\r\n            this.onScroll = function () {\r\n                _this.refresh_internal(false);\r\n            };\r\n        }\r\n    };\r\n    Object.defineProperty(VirtualScrollerComponent.prototype, \"checkResizeInterval\", {\r\n        get: function () {\r\n            return this._checkResizeInterval;\r\n        },\r\n        set: function (value) {\r\n            if (this._checkResizeInterval === value) {\r\n                return;\r\n            }\r\n            this._checkResizeInterval = value;\r\n            this.addScrollEventHandlers();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VirtualScrollerComponent.prototype, \"items\", {\r\n        get: function () {\r\n            return this._items;\r\n        },\r\n        set: function (value) {\r\n            if (value === this._items) {\r\n                return;\r\n            }\r\n            this._items = value || [];\r\n            this.refresh_internal(true);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(VirtualScrollerComponent.prototype, \"horizontal\", {\r\n        get: function () {\r\n            return this._horizontal;\r\n        },\r\n        set: function (value) {\r\n            this._horizontal = value;\r\n            this.updateDirection();\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    VirtualScrollerComponent.prototype.revertParentOverscroll = function () {\r\n        var scrollElement = this.getScrollElement();\r\n        if (scrollElement && this.oldParentScrollOverflow) {\r\n            scrollElement.style['overflow-y'] = this.oldParentScrollOverflow.y;\r\n            scrollElement.style['overflow-x'] = this.oldParentScrollOverflow.x;\r\n        }\r\n        this.oldParentScrollOverflow = undefined;\r\n    };\r\n    Object.defineProperty(VirtualScrollerComponent.prototype, \"parentScroll\", {\r\n        get: function () {\r\n            return this._parentScroll;\r\n        },\r\n        set: function (value) {\r\n            if (this._parentScroll === value) {\r\n                return;\r\n            }\r\n            this.revertParentOverscroll();\r\n            this._parentScroll = value;\r\n            this.addScrollEventHandlers();\r\n            var scrollElement = this.getScrollElement();\r\n            if (this.modifyOverflowStyleOfParentScroll && scrollElement !== this.element.nativeElement) {\r\n                this.oldParentScrollOverflow = { x: scrollElement.style['overflow-x'], y: scrollElement.style['overflow-y'] };\r\n                scrollElement.style['overflow-y'] = this.horizontal ? 'visible' : 'auto';\r\n                scrollElement.style['overflow-x'] = this.horizontal ? 'auto' : 'visible';\r\n            }\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    VirtualScrollerComponent.prototype.ngOnInit = function () {\r\n        this.addScrollEventHandlers();\r\n    };\r\n    VirtualScrollerComponent.prototype.ngOnDestroy = function () {\r\n        this.removeScrollEventHandlers();\r\n        this.revertParentOverscroll();\r\n    };\r\n    VirtualScrollerComponent.prototype.ngOnChanges = function (changes) {\r\n        var indexLengthChanged = this.cachedItemsLength !== this.items.length;\r\n        this.cachedItemsLength = this.items.length;\r\n        var firstRun = !changes.items || !changes.items.previousValue || changes.items.previousValue.length === 0;\r\n        this.refresh_internal(indexLengthChanged || firstRun);\r\n    };\r\n    VirtualScrollerComponent.prototype.ngDoCheck = function () {\r\n        if (this.cachedItemsLength !== this.items.length) {\r\n            this.cachedItemsLength = this.items.length;\r\n            this.refresh_internal(true);\r\n        }\r\n    };\r\n    VirtualScrollerComponent.prototype.refresh = function () {\r\n        this.refresh_internal(true);\r\n    };\r\n    VirtualScrollerComponent.prototype.invalidateAllCachedMeasurements = function () {\r\n        this.wrapGroupDimensions = {\r\n            maxChildSizePerWrapGroup: [],\r\n            numberOfKnownWrapGroupChildSizes: 0,\r\n            sumOfKnownWrapGroupChildWidths: 0,\r\n            sumOfKnownWrapGroupChildHeights: 0\r\n        };\r\n        this.minMeasuredChildWidth = undefined;\r\n        this.minMeasuredChildHeight = undefined;\r\n        this.refresh_internal(false);\r\n    };\r\n    VirtualScrollerComponent.prototype.invalidateCachedMeasurementForItem = function (item) {\r\n        if (this.enableUnequalChildrenSizes) {\r\n            var index = this.items && this.items.indexOf(item);\r\n            if (index >= 0) {\r\n                this.invalidateCachedMeasurementAtIndex(index);\r\n            }\r\n        }\r\n        else {\r\n            this.minMeasuredChildWidth = undefined;\r\n            this.minMeasuredChildHeight = undefined;\r\n        }\r\n        this.refresh_internal(false);\r\n    };\r\n    VirtualScrollerComponent.prototype.invalidateCachedMeasurementAtIndex = function (index) {\r\n        if (this.enableUnequalChildrenSizes) {\r\n            var cachedMeasurement = this.wrapGroupDimensions.maxChildSizePerWrapGroup[index];\r\n            if (cachedMeasurement) {\r\n                this.wrapGroupDimensions.maxChildSizePerWrapGroup[index] = undefined;\r\n                --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n                this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= cachedMeasurement.childWidth || 0;\r\n                this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= cachedMeasurement.childHeight || 0;\r\n            }\r\n        }\r\n        else {\r\n            this.minMeasuredChildWidth = undefined;\r\n            this.minMeasuredChildHeight = undefined;\r\n        }\r\n        this.refresh_internal(false);\r\n    };\r\n    VirtualScrollerComponent.prototype.scrollInto = function (item, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback) {\r\n        if (alignToBeginning === void 0) { alignToBeginning = true; }\r\n        if (additionalOffset === void 0) { additionalOffset = 0; }\r\n        if (animationMilliseconds === void 0) { animationMilliseconds = undefined; }\r\n        if (animationCompletedCallback === void 0) { animationCompletedCallback = undefined; }\r\n        var index = this.items.indexOf(item);\r\n        if (index === -1) {\r\n            return;\r\n        }\r\n        this.scrollToIndex(index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback);\r\n    };\r\n    VirtualScrollerComponent.prototype.scrollToIndex = function (index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback) {\r\n        var _this = this;\r\n        if (alignToBeginning === void 0) { alignToBeginning = true; }\r\n        if (additionalOffset === void 0) { additionalOffset = 0; }\r\n        if (animationMilliseconds === void 0) { animationMilliseconds = undefined; }\r\n        if (animationCompletedCallback === void 0) { animationCompletedCallback = undefined; }\r\n        var maxRetries = 5;\r\n        var retryIfNeeded = function () {\r\n            --maxRetries;\r\n            if (maxRetries <= 0) {\r\n                if (animationCompletedCallback) {\r\n                    animationCompletedCallback();\r\n                }\r\n                return;\r\n            }\r\n            var dimensions = _this.calculateDimensions();\r\n            var desiredStartIndex = Math.min(Math.max(index, 0), dimensions.itemCount - 1);\r\n            if (_this.previousViewPort.startIndex === desiredStartIndex) {\r\n                if (animationCompletedCallback) {\r\n                    animationCompletedCallback();\r\n                }\r\n                return;\r\n            }\r\n            _this.scrollToIndex_internal(index, alignToBeginning, additionalOffset, 0, retryIfNeeded);\r\n        };\r\n        this.scrollToIndex_internal(index, alignToBeginning, additionalOffset, animationMilliseconds, retryIfNeeded);\r\n    };\r\n    VirtualScrollerComponent.prototype.scrollToIndex_internal = function (index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback) {\r\n        if (alignToBeginning === void 0) { alignToBeginning = true; }\r\n        if (additionalOffset === void 0) { additionalOffset = 0; }\r\n        if (animationMilliseconds === void 0) { animationMilliseconds = undefined; }\r\n        if (animationCompletedCallback === void 0) { animationCompletedCallback = undefined; }\r\n        animationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;\r\n        var dimensions = this.calculateDimensions();\r\n        var scroll = this.calculatePadding(index, dimensions) + additionalOffset;\r\n        if (!alignToBeginning) {\r\n            scroll -= dimensions.wrapGroupsPerPage * dimensions[this._childScrollDim];\r\n        }\r\n        this.scrollToPosition(scroll, animationMilliseconds, animationCompletedCallback);\r\n    };\r\n    VirtualScrollerComponent.prototype.scrollToPosition = function (scrollPosition, animationMilliseconds, animationCompletedCallback) {\r\n        var _this = this;\r\n        if (animationMilliseconds === void 0) { animationMilliseconds = undefined; }\r\n        if (animationCompletedCallback === void 0) { animationCompletedCallback = undefined; }\r\n        scrollPosition += this.getElementsOffset();\r\n        animationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;\r\n        var scrollElement = this.getScrollElement();\r\n        var animationRequest;\r\n        if (this.currentTween) {\r\n            this.currentTween.stop();\r\n            this.currentTween = undefined;\r\n        }\r\n        if (!animationMilliseconds) {\r\n            this.renderer.setProperty(scrollElement, this._scrollType, scrollPosition);\r\n            this.refresh_internal(false, animationCompletedCallback);\r\n            return;\r\n        }\r\n        var tweenConfigObj = { scrollPosition: scrollElement[this._scrollType] };\r\n        var newTween = new tween.Tween(tweenConfigObj)\r\n            .to({ scrollPosition: scrollPosition }, animationMilliseconds)\r\n            .easing(tween.Easing.Quadratic.Out)\r\n            .onUpdate(function (data) {\r\n            if (isNaN(data.scrollPosition)) {\r\n                return;\r\n            }\r\n            _this.renderer.setProperty(scrollElement, _this._scrollType, data.scrollPosition);\r\n            _this.refresh_internal(false);\r\n        })\r\n            .onStop(function () {\r\n            cancelAnimationFrame(animationRequest);\r\n        })\r\n            .start();\r\n        var animate = function (time) {\r\n            if (!newTween[\"isPlaying\"]()) {\r\n                return;\r\n            }\r\n            newTween.update(time);\r\n            if (tweenConfigObj.scrollPosition === scrollPosition) {\r\n                _this.refresh_internal(false, animationCompletedCallback);\r\n                return;\r\n            }\r\n            _this.zone.runOutsideAngular(function () {\r\n                animationRequest = requestAnimationFrame(animate);\r\n            });\r\n        };\r\n        animate();\r\n        this.currentTween = newTween;\r\n    };\r\n    VirtualScrollerComponent.prototype.checkScrollElementResized = function () {\r\n        var boundingRect = this.getScrollElement().getBoundingClientRect();\r\n        var sizeChanged;\r\n        if (!this.previousScrollBoundingRect) {\r\n            sizeChanged = true;\r\n        }\r\n        else {\r\n            var widthChange = Math.abs(boundingRect.width - this.previousScrollBoundingRect.width);\r\n            var heightChange = Math.abs(boundingRect.height - this.previousScrollBoundingRect.height);\r\n            sizeChanged = widthChange > this.resizeBypassRefreshThreshold || heightChange > this.resizeBypassRefreshThreshold;\r\n        }\r\n        if (sizeChanged) {\r\n            this.previousScrollBoundingRect = boundingRect;\r\n            if (boundingRect.width > 0 && boundingRect.height > 0) {\r\n                this.refresh_internal(false);\r\n            }\r\n        }\r\n    };\r\n    VirtualScrollerComponent.prototype.updateDirection = function () {\r\n        if (this.horizontal) {\r\n            this._invisiblePaddingProperty = 'width';\r\n            this._offsetType = 'offsetLeft';\r\n            this._pageOffsetType = 'pageXOffset';\r\n            this._childScrollDim = 'childWidth';\r\n            this._marginDir = 'margin-left';\r\n            this._translateDir = 'translateX';\r\n            this._scrollType = 'scrollLeft';\r\n        }\r\n        else {\r\n            this._invisiblePaddingProperty = 'height';\r\n            this._offsetType = 'offsetTop';\r\n            this._pageOffsetType = 'pageYOffset';\r\n            this._childScrollDim = 'childHeight';\r\n            this._marginDir = 'margin-top';\r\n            this._translateDir = 'translateY';\r\n            this._scrollType = 'scrollTop';\r\n        }\r\n    };\r\n    VirtualScrollerComponent.prototype.debounce = function (func, wait) {\r\n        var throttled = this.throttleTrailing(func, wait);\r\n        var result = function () {\r\n            throttled['cancel']();\r\n            throttled.apply(this, arguments);\r\n        };\r\n        result['cancel'] = function () {\r\n            throttled['cancel']();\r\n        };\r\n        return result;\r\n    };\r\n    VirtualScrollerComponent.prototype.throttleTrailing = function (func, wait) {\r\n        var timeout = undefined;\r\n        var result = function () {\r\n            var _this = this;\r\n            var _arguments = arguments;\r\n            if (timeout) {\r\n                return;\r\n            }\r\n            if (wait <= 0) {\r\n                func.apply(_this, _arguments);\r\n            }\r\n            else {\r\n                timeout = setTimeout(function () {\r\n                    timeout = undefined;\r\n                    func.apply(_this, _arguments);\r\n                }, wait);\r\n            }\r\n        };\r\n        result['cancel'] = function () {\r\n            if (timeout) {\r\n                clearTimeout(timeout);\r\n                timeout = undefined;\r\n            }\r\n        };\r\n        return result;\r\n    };\r\n    VirtualScrollerComponent.prototype.refresh_internal = function (itemsArrayModified, refreshCompletedCallback, maxRunTimes) {\r\n        //note: maxRunTimes is to force it to keep recalculating if the previous iteration caused a re-render (different sliced items in viewport or scrollPosition changed).\r\n        //The default of 2x max will probably be accurate enough without causing too large a performance bottleneck\r\n        //The code would typically quit out on the 2nd iteration anyways. The main time it'd think more than 2 runs would be necessary would be for vastly different sized child items or if this is the 1st time the items array was initialized.\r\n        //Without maxRunTimes, If the user is actively scrolling this code would become an infinite loop until they stopped scrolling. This would be okay, except each scroll event would start an additional infinte loop. We want to short-circuit it to prevent his.\r\n        var _this = this;\r\n        if (refreshCompletedCallback === void 0) { refreshCompletedCallback = undefined; }\r\n        if (maxRunTimes === void 0) { maxRunTimes = 2; }\r\n        this.zone.runOutsideAngular(function () {\r\n            requestAnimationFrame(function () {\r\n                if (itemsArrayModified) {\r\n                    _this.resetWrapGroupDimensions();\r\n                }\r\n                var viewport = _this.calculateViewport();\r\n                var startChanged = itemsArrayModified || viewport.startIndex !== _this.previousViewPort.startIndex;\r\n                var endChanged = itemsArrayModified || viewport.endIndex !== _this.previousViewPort.endIndex;\r\n                var scrollLengthChanged = viewport.scrollLength !== _this.previousViewPort.scrollLength;\r\n                var paddingChanged = viewport.padding !== _this.previousViewPort.padding;\r\n                var scrollPositionChanged = viewport.scrollStartPosition !== _this.previousViewPort.scrollStartPosition || viewport.scrollEndPosition !== _this.previousViewPort.scrollEndPosition || viewport.maxScrollPosition !== _this.previousViewPort.maxScrollPosition;\r\n                _this.previousViewPort = viewport;\r\n                if (scrollLengthChanged) {\r\n                    _this.renderer.setStyle(_this.invisiblePaddingElementRef.nativeElement, _this._invisiblePaddingProperty, viewport.scrollLength + \"px\");\r\n                }\r\n                if (paddingChanged) {\r\n                    if (_this.useMarginInsteadOfTranslate) {\r\n                        _this.renderer.setStyle(_this.contentElementRef.nativeElement, _this._marginDir, viewport.padding + \"px\");\r\n                    }\r\n                    else {\r\n                        _this.renderer.setStyle(_this.contentElementRef.nativeElement, 'transform', _this._translateDir + \"(\" + viewport.padding + \"px)\");\r\n                        _this.renderer.setStyle(_this.contentElementRef.nativeElement, 'webkitTransform', _this._translateDir + \"(\" + viewport.padding + \"px)\");\r\n                    }\r\n                }\r\n                if (_this.headerElementRef) {\r\n                    var scrollPosition = _this.getScrollElement()[_this._scrollType];\r\n                    var containerOffset = _this.getElementsOffset();\r\n                    var offset = Math.max(scrollPosition - viewport.padding - containerOffset + _this.headerElementRef.nativeElement.clientHeight, 0);\r\n                    _this.renderer.setStyle(_this.headerElementRef.nativeElement, 'transform', _this._translateDir + \"(\" + offset + \"px)\");\r\n                    _this.renderer.setStyle(_this.headerElementRef.nativeElement, 'webkitTransform', _this._translateDir + \"(\" + offset + \"px)\");\r\n                }\r\n                var changeEventArg = (startChanged || endChanged) ? {\r\n                    start: viewport.startIndex,\r\n                    end: viewport.endIndex,\r\n                    startIndex: viewport.startIndex,\r\n                    endIndex: viewport.endIndex,\r\n                    scrollStartPosition: viewport.scrollStartPosition,\r\n                    scrollEndPosition: viewport.scrollEndPosition,\r\n                    startIndexWithBuffer: viewport.startIndexWithBuffer,\r\n                    endIndexWithBuffer: viewport.endIndexWithBuffer,\r\n                    maxScrollPosition: viewport.maxScrollPosition\r\n                } : undefined;\r\n                if (startChanged || endChanged || scrollPositionChanged) {\r\n                    var handleChanged = function () {\r\n                        // update the scroll list to trigger re-render of components in viewport\r\n                        _this.viewPortItems = viewport.startIndexWithBuffer >= 0 && viewport.endIndexWithBuffer >= 0 ? _this.items.slice(viewport.startIndexWithBuffer, viewport.endIndexWithBuffer + 1) : [];\r\n                        _this.update.emit(_this.viewPortItems);\r\n                        _this.vsUpdate.emit(_this.viewPortItems);\r\n                        if (startChanged) {\r\n                            _this.start.emit(changeEventArg);\r\n                            _this.vsStart.emit(changeEventArg);\r\n                        }\r\n                        if (endChanged) {\r\n                            _this.end.emit(changeEventArg);\r\n                            _this.vsEnd.emit(changeEventArg);\r\n                        }\r\n                        if (startChanged || endChanged) {\r\n                            _this.changeDetectorRef.markForCheck();\r\n                            _this.change.emit(changeEventArg);\r\n                            _this.vsChange.emit(changeEventArg);\r\n                        }\r\n                        if (maxRunTimes > 0) {\r\n                            _this.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);\r\n                            return;\r\n                        }\r\n                        if (refreshCompletedCallback) {\r\n                            refreshCompletedCallback();\r\n                        }\r\n                    };\r\n                    if (_this.executeRefreshOutsideAngularZone) {\r\n                        handleChanged();\r\n                    }\r\n                    else {\r\n                        _this.zone.run(handleChanged);\r\n                    }\r\n                }\r\n                else {\r\n                    if (maxRunTimes > 0 && (scrollLengthChanged || paddingChanged)) {\r\n                        _this.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);\r\n                        return;\r\n                    }\r\n                    if (refreshCompletedCallback) {\r\n                        refreshCompletedCallback();\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    };\r\n    VirtualScrollerComponent.prototype.getScrollElement = function () {\r\n        return this.parentScroll instanceof Window ? document.scrollingElement || document.documentElement || document.body : this.parentScroll || this.element.nativeElement;\r\n    };\r\n    VirtualScrollerComponent.prototype.addScrollEventHandlers = function () {\r\n        var _this = this;\r\n        if (this.isAngularUniversalSSR) {\r\n            return;\r\n        }\r\n        var scrollElement = this.getScrollElement();\r\n        this.removeScrollEventHandlers();\r\n        this.zone.runOutsideAngular(function () {\r\n            if (_this.parentScroll instanceof Window) {\r\n                _this.disposeScrollHandler = _this.renderer.listen('window', 'scroll', _this.onScroll);\r\n                _this.disposeResizeHandler = _this.renderer.listen('window', 'resize', _this.onScroll);\r\n            }\r\n            else {\r\n                _this.disposeScrollHandler = _this.renderer.listen(scrollElement, 'scroll', _this.onScroll);\r\n                if (_this._checkResizeInterval > 0) {\r\n                    _this.checkScrollElementResizedTimer = setInterval(function () { _this.checkScrollElementResized(); }, _this._checkResizeInterval);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    VirtualScrollerComponent.prototype.removeScrollEventHandlers = function () {\r\n        if (this.checkScrollElementResizedTimer) {\r\n            clearInterval(this.checkScrollElementResizedTimer);\r\n        }\r\n        if (this.disposeScrollHandler) {\r\n            this.disposeScrollHandler();\r\n            this.disposeScrollHandler = undefined;\r\n        }\r\n        if (this.disposeResizeHandler) {\r\n            this.disposeResizeHandler();\r\n            this.disposeResizeHandler = undefined;\r\n        }\r\n    };\r\n    VirtualScrollerComponent.prototype.getElementsOffset = function () {\r\n        if (this.isAngularUniversalSSR) {\r\n            return 0;\r\n        }\r\n        var offset = 0;\r\n        if (this.containerElementRef && this.containerElementRef.nativeElement) {\r\n            offset += this.containerElementRef.nativeElement[this._offsetType];\r\n        }\r\n        if (this.parentScroll) {\r\n            var scrollElement = this.getScrollElement();\r\n            var elementClientRect = this.element.nativeElement.getBoundingClientRect();\r\n            var scrollClientRect = scrollElement.getBoundingClientRect();\r\n            if (this.horizontal) {\r\n                offset += elementClientRect.left - scrollClientRect.left;\r\n            }\r\n            else {\r\n                offset += elementClientRect.top - scrollClientRect.top;\r\n            }\r\n            if (!(this.parentScroll instanceof Window)) {\r\n                offset += scrollElement[this._scrollType];\r\n            }\r\n        }\r\n        return offset;\r\n    };\r\n    VirtualScrollerComponent.prototype.countItemsPerWrapGroup = function () {\r\n        if (this.isAngularUniversalSSR) {\r\n            return Math.round(this.horizontal ? this.ssrViewportHeight / this.ssrChildHeight : this.ssrViewportWidth / this.ssrChildWidth);\r\n        }\r\n        var propertyName = this.horizontal ? 'offsetLeft' : 'offsetTop';\r\n        var children = ((this.containerElementRef && this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement).children;\r\n        var childrenLength = children ? children.length : 0;\r\n        if (childrenLength === 0) {\r\n            return 1;\r\n        }\r\n        var firstOffset = children[0][propertyName];\r\n        var result = 1;\r\n        while (result < childrenLength && firstOffset === children[result][propertyName]) {\r\n            ++result;\r\n        }\r\n        return result;\r\n    };\r\n    VirtualScrollerComponent.prototype.getScrollStartPosition = function () {\r\n        var windowScrollValue = undefined;\r\n        if (this.parentScroll instanceof Window) {\r\n            windowScrollValue = window[this._pageOffsetType];\r\n        }\r\n        return windowScrollValue || this.getScrollElement()[this._scrollType] || 0;\r\n    };\r\n    VirtualScrollerComponent.prototype.resetWrapGroupDimensions = function () {\r\n        var oldWrapGroupDimensions = this.wrapGroupDimensions;\r\n        this.invalidateAllCachedMeasurements();\r\n        if (!this.enableUnequalChildrenSizes || !oldWrapGroupDimensions || oldWrapGroupDimensions.numberOfKnownWrapGroupChildSizes === 0) {\r\n            return;\r\n        }\r\n        var itemsPerWrapGroup = this.countItemsPerWrapGroup();\r\n        for (var wrapGroupIndex = 0; wrapGroupIndex < oldWrapGroupDimensions.maxChildSizePerWrapGroup.length; ++wrapGroupIndex) {\r\n            var oldWrapGroupDimension = oldWrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];\r\n            if (!oldWrapGroupDimension || !oldWrapGroupDimension.items || !oldWrapGroupDimension.items.length) {\r\n                continue;\r\n            }\r\n            if (oldWrapGroupDimension.items.length !== itemsPerWrapGroup) {\r\n                return;\r\n            }\r\n            var itemsChanged = false;\r\n            var arrayStartIndex = itemsPerWrapGroup * wrapGroupIndex;\r\n            for (var i = 0; i < itemsPerWrapGroup; ++i) {\r\n                if (!this.compareItems(oldWrapGroupDimension.items[i], this.items[arrayStartIndex + i])) {\r\n                    itemsChanged = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!itemsChanged) {\r\n                ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n                this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += oldWrapGroupDimension.childWidth || 0;\r\n                this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += oldWrapGroupDimension.childHeight || 0;\r\n                this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = oldWrapGroupDimension;\r\n            }\r\n        }\r\n    };\r\n    VirtualScrollerComponent.prototype.calculateDimensions = function () {\r\n        var scrollElement = this.getScrollElement();\r\n        var maxCalculatedScrollBarSize = 25; // Note: Formula to auto-calculate doesn't work for ParentScroll, so we default to this if not set by consuming application\r\n        this.calculatedScrollbarHeight = Math.max(Math.min(scrollElement.offsetHeight - scrollElement.clientHeight, maxCalculatedScrollBarSize), this.calculatedScrollbarHeight);\r\n        this.calculatedScrollbarWidth = Math.max(Math.min(scrollElement.offsetWidth - scrollElement.clientWidth, maxCalculatedScrollBarSize), this.calculatedScrollbarWidth);\r\n        var viewportWidth = scrollElement.offsetWidth - (this.scrollbarWidth || this.calculatedScrollbarWidth || (this.horizontal ? 0 : maxCalculatedScrollBarSize));\r\n        var viewportHeight = scrollElement.offsetHeight - (this.scrollbarHeight || this.calculatedScrollbarHeight || (this.horizontal ? maxCalculatedScrollBarSize : 0));\r\n        var content = (this.containerElementRef && this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement;\r\n        var itemsPerWrapGroup = this.countItemsPerWrapGroup();\r\n        var wrapGroupsPerPage;\r\n        var defaultChildWidth;\r\n        var defaultChildHeight;\r\n        if (this.isAngularUniversalSSR) {\r\n            viewportWidth = this.ssrViewportWidth;\r\n            viewportHeight = this.ssrViewportHeight;\r\n            defaultChildWidth = this.ssrChildWidth;\r\n            defaultChildHeight = this.ssrChildHeight;\r\n            var itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);\r\n            var itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);\r\n            wrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;\r\n        }\r\n        else if (!this.enableUnequalChildrenSizes) {\r\n            if (content.children.length > 0) {\r\n                if (!this.childWidth || !this.childHeight) {\r\n                    if (!this.minMeasuredChildWidth && viewportWidth > 0) {\r\n                        this.minMeasuredChildWidth = viewportWidth;\r\n                    }\r\n                    if (!this.minMeasuredChildHeight && viewportHeight > 0) {\r\n                        this.minMeasuredChildHeight = viewportHeight;\r\n                    }\r\n                }\r\n                var child = content.children[0];\r\n                var clientRect = child.getBoundingClientRect();\r\n                this.minMeasuredChildWidth = Math.min(this.minMeasuredChildWidth, clientRect.width);\r\n                this.minMeasuredChildHeight = Math.min(this.minMeasuredChildHeight, clientRect.height);\r\n            }\r\n            defaultChildWidth = this.childWidth || this.minMeasuredChildWidth || viewportWidth;\r\n            defaultChildHeight = this.childHeight || this.minMeasuredChildHeight || viewportHeight;\r\n            var itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);\r\n            var itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);\r\n            wrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;\r\n        }\r\n        else {\r\n            var scrollOffset = scrollElement[this._scrollType] - (this.previousViewPort ? this.previousViewPort.padding : 0);\r\n            var arrayStartIndex = this.previousViewPort.startIndexWithBuffer || 0;\r\n            var wrapGroupIndex = Math.ceil(arrayStartIndex / itemsPerWrapGroup);\r\n            var maxWidthForWrapGroup = 0;\r\n            var maxHeightForWrapGroup = 0;\r\n            var sumOfVisibleMaxWidths = 0;\r\n            var sumOfVisibleMaxHeights = 0;\r\n            wrapGroupsPerPage = 0;\r\n            for (var i = 0; i < content.children.length; ++i) {\r\n                ++arrayStartIndex;\r\n                var child = content.children[i];\r\n                var clientRect = child.getBoundingClientRect();\r\n                maxWidthForWrapGroup = Math.max(maxWidthForWrapGroup, clientRect.width);\r\n                maxHeightForWrapGroup = Math.max(maxHeightForWrapGroup, clientRect.height);\r\n                if (arrayStartIndex % itemsPerWrapGroup === 0) {\r\n                    var oldValue = this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];\r\n                    if (oldValue) {\r\n                        --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= oldValue.childWidth || 0;\r\n                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= oldValue.childHeight || 0;\r\n                    }\r\n                    ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n                    var items = this.items.slice(arrayStartIndex - itemsPerWrapGroup, arrayStartIndex);\r\n                    this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = {\r\n                        childWidth: maxWidthForWrapGroup,\r\n                        childHeight: maxHeightForWrapGroup,\r\n                        items: items\r\n                    };\r\n                    this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += maxWidthForWrapGroup;\r\n                    this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += maxHeightForWrapGroup;\r\n                    if (this.horizontal) {\r\n                        var maxVisibleWidthForWrapGroup = Math.min(maxWidthForWrapGroup, Math.max(viewportWidth - sumOfVisibleMaxWidths, 0));\r\n                        if (scrollOffset > 0) {\r\n                            var scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleWidthForWrapGroup);\r\n                            maxVisibleWidthForWrapGroup -= scrollOffsetToRemove;\r\n                            scrollOffset -= scrollOffsetToRemove;\r\n                        }\r\n                        sumOfVisibleMaxWidths += maxVisibleWidthForWrapGroup;\r\n                        if (maxVisibleWidthForWrapGroup > 0 && viewportWidth >= sumOfVisibleMaxWidths) {\r\n                            ++wrapGroupsPerPage;\r\n                        }\r\n                    }\r\n                    else {\r\n                        var maxVisibleHeightForWrapGroup = Math.min(maxHeightForWrapGroup, Math.max(viewportHeight - sumOfVisibleMaxHeights, 0));\r\n                        if (scrollOffset > 0) {\r\n                            var scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleHeightForWrapGroup);\r\n                            maxVisibleHeightForWrapGroup -= scrollOffsetToRemove;\r\n                            scrollOffset -= scrollOffsetToRemove;\r\n                        }\r\n                        sumOfVisibleMaxHeights += maxVisibleHeightForWrapGroup;\r\n                        if (maxVisibleHeightForWrapGroup > 0 && viewportHeight >= sumOfVisibleMaxHeights) {\r\n                            ++wrapGroupsPerPage;\r\n                        }\r\n                    }\r\n                    ++wrapGroupIndex;\r\n                    maxWidthForWrapGroup = 0;\r\n                    maxHeightForWrapGroup = 0;\r\n                }\r\n            }\r\n            var averageChildWidth = this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n            var averageChildHeight = this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\r\n            defaultChildWidth = this.childWidth || averageChildWidth || viewportWidth;\r\n            defaultChildHeight = this.childHeight || averageChildHeight || viewportHeight;\r\n            if (this.horizontal) {\r\n                if (viewportWidth > sumOfVisibleMaxWidths) {\r\n                    wrapGroupsPerPage += Math.ceil((viewportWidth - sumOfVisibleMaxWidths) / defaultChildWidth);\r\n                }\r\n            }\r\n            else {\r\n                if (viewportHeight > sumOfVisibleMaxHeights) {\r\n                    wrapGroupsPerPage += Math.ceil((viewportHeight - sumOfVisibleMaxHeights) / defaultChildHeight);\r\n                }\r\n            }\r\n        }\r\n        var itemCount = this.items.length;\r\n        var itemsPerPage = itemsPerWrapGroup * wrapGroupsPerPage;\r\n        var pageCount_fractional = itemCount / itemsPerPage;\r\n        var numberOfWrapGroups = Math.ceil(itemCount / itemsPerWrapGroup);\r\n        var scrollLength = 0;\r\n        var defaultScrollLengthPerWrapGroup = this.horizontal ? defaultChildWidth : defaultChildHeight;\r\n        if (this.enableUnequalChildrenSizes) {\r\n            var numUnknownChildSizes = 0;\r\n            for (var i = 0; i < numberOfWrapGroups; ++i) {\r\n                var childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\r\n                if (childSize) {\r\n                    scrollLength += childSize;\r\n                }\r\n                else {\r\n                    ++numUnknownChildSizes;\r\n                }\r\n            }\r\n            scrollLength += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);\r\n        }\r\n        else {\r\n            scrollLength = numberOfWrapGroups * defaultScrollLengthPerWrapGroup;\r\n        }\r\n        if (this.headerElementRef) {\r\n            scrollLength += this.headerElementRef.nativeElement.clientHeight;\r\n        }\r\n        var viewportLength = this.horizontal ? viewportWidth : viewportHeight;\r\n        var maxScrollPosition = Math.max(scrollLength - viewportLength, 0);\r\n        return {\r\n            itemCount: itemCount,\r\n            itemsPerWrapGroup: itemsPerWrapGroup,\r\n            wrapGroupsPerPage: wrapGroupsPerPage,\r\n            itemsPerPage: itemsPerPage,\r\n            pageCount_fractional: pageCount_fractional,\r\n            childWidth: defaultChildWidth,\r\n            childHeight: defaultChildHeight,\r\n            scrollLength: scrollLength,\r\n            viewportLength: viewportLength,\r\n            maxScrollPosition: maxScrollPosition\r\n        };\r\n    };\r\n    VirtualScrollerComponent.prototype.calculatePadding = function (arrayStartIndexWithBuffer, dimensions) {\r\n        if (dimensions.itemCount === 0) {\r\n            return 0;\r\n        }\r\n        var defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];\r\n        var startingWrapGroupIndex = Math.floor(arrayStartIndexWithBuffer / dimensions.itemsPerWrapGroup) || 0;\r\n        if (!this.enableUnequalChildrenSizes) {\r\n            return defaultScrollLengthPerWrapGroup * startingWrapGroupIndex;\r\n        }\r\n        var numUnknownChildSizes = 0;\r\n        var result = 0;\r\n        for (var i = 0; i < startingWrapGroupIndex; ++i) {\r\n            var childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\r\n            if (childSize) {\r\n                result += childSize;\r\n            }\r\n            else {\r\n                ++numUnknownChildSizes;\r\n            }\r\n        }\r\n        result += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);\r\n        return result;\r\n    };\r\n    VirtualScrollerComponent.prototype.calculatePageInfo = function (scrollPosition, dimensions) {\r\n        var scrollPercentage = 0;\r\n        if (this.enableUnequalChildrenSizes) {\r\n            var numberOfWrapGroups = Math.ceil(dimensions.itemCount / dimensions.itemsPerWrapGroup);\r\n            var totalScrolledLength = 0;\r\n            var defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];\r\n            for (var i = 0; i < numberOfWrapGroups; ++i) {\r\n                var childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\r\n                if (childSize) {\r\n                    totalScrolledLength += childSize;\r\n                }\r\n                else {\r\n                    totalScrolledLength += defaultScrollLengthPerWrapGroup;\r\n                }\r\n                if (scrollPosition < totalScrolledLength) {\r\n                    scrollPercentage = i / numberOfWrapGroups;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            scrollPercentage = scrollPosition / dimensions.scrollLength;\r\n        }\r\n        var startingArrayIndex_fractional = Math.min(Math.max(scrollPercentage * dimensions.pageCount_fractional, 0), dimensions.pageCount_fractional) * dimensions.itemsPerPage;\r\n        var maxStart = dimensions.itemCount - dimensions.itemsPerPage - 1;\r\n        var arrayStartIndex = Math.min(Math.floor(startingArrayIndex_fractional), maxStart);\r\n        arrayStartIndex -= arrayStartIndex % dimensions.itemsPerWrapGroup; // round down to start of wrapGroup\r\n        if (this.stripedTable) {\r\n            var bufferBoundary = 2 * dimensions.itemsPerWrapGroup;\r\n            if (arrayStartIndex % bufferBoundary !== 0) {\r\n                arrayStartIndex = Math.max(arrayStartIndex - arrayStartIndex % bufferBoundary, 0);\r\n            }\r\n        }\r\n        var arrayEndIndex = Math.ceil(startingArrayIndex_fractional) + dimensions.itemsPerPage - 1;\r\n        var endIndexWithinWrapGroup = (arrayEndIndex + 1) % dimensions.itemsPerWrapGroup;\r\n        if (endIndexWithinWrapGroup > 0) {\r\n            arrayEndIndex += dimensions.itemsPerWrapGroup - endIndexWithinWrapGroup; // round up to end of wrapGroup\r\n        }\r\n        if (isNaN(arrayStartIndex)) {\r\n            arrayStartIndex = 0;\r\n        }\r\n        if (isNaN(arrayEndIndex)) {\r\n            arrayEndIndex = 0;\r\n        }\r\n        arrayStartIndex = Math.min(Math.max(arrayStartIndex, 0), dimensions.itemCount - 1);\r\n        arrayEndIndex = Math.min(Math.max(arrayEndIndex, 0), dimensions.itemCount - 1);\r\n        var bufferSize = this.bufferAmount * dimensions.itemsPerWrapGroup;\r\n        var startIndexWithBuffer = Math.min(Math.max(arrayStartIndex - bufferSize, 0), dimensions.itemCount - 1);\r\n        var endIndexWithBuffer = Math.min(Math.max(arrayEndIndex + bufferSize, 0), dimensions.itemCount - 1);\r\n        return {\r\n            startIndex: arrayStartIndex,\r\n            endIndex: arrayEndIndex,\r\n            startIndexWithBuffer: startIndexWithBuffer,\r\n            endIndexWithBuffer: endIndexWithBuffer,\r\n            scrollStartPosition: scrollPosition,\r\n            scrollEndPosition: scrollPosition + dimensions.viewportLength,\r\n            maxScrollPosition: dimensions.maxScrollPosition\r\n        };\r\n    };\r\n    VirtualScrollerComponent.prototype.calculateViewport = function () {\r\n        var dimensions = this.calculateDimensions();\r\n        var offset = this.getElementsOffset();\r\n        var scrollStartPosition = this.getScrollStartPosition();\r\n        if (scrollStartPosition > (dimensions.scrollLength + offset) && !(this.parentScroll instanceof Window)) {\r\n            scrollStartPosition = dimensions.scrollLength;\r\n        }\r\n        else {\r\n            scrollStartPosition -= offset;\r\n        }\r\n        scrollStartPosition = Math.max(0, scrollStartPosition);\r\n        var pageInfo = this.calculatePageInfo(scrollStartPosition, dimensions);\r\n        var newPadding = this.calculatePadding(pageInfo.startIndexWithBuffer, dimensions);\r\n        var newScrollLength = dimensions.scrollLength;\r\n        return {\r\n            startIndex: pageInfo.startIndex,\r\n            endIndex: pageInfo.endIndex,\r\n            startIndexWithBuffer: pageInfo.startIndexWithBuffer,\r\n            endIndexWithBuffer: pageInfo.endIndexWithBuffer,\r\n            padding: Math.round(newPadding),\r\n            scrollLength: Math.round(newScrollLength),\r\n            scrollStartPosition: pageInfo.scrollStartPosition,\r\n            scrollEndPosition: pageInfo.scrollEndPosition,\r\n            maxScrollPosition: pageInfo.maxScrollPosition\r\n        };\r\n    };\r\n    return VirtualScrollerComponent;\r\n}());\r\nVirtualScrollerComponent.decorators = [\r\n    { type: core_1.Component, args: [{\r\n                selector: 'virtual-scroller,[virtualScroller]',\r\n                exportAs: 'virtualScroller',\r\n                template: \"\\n    <div class=\\\"total-padding\\\" #invisiblePadding></div>\\n    <div class=\\\"scrollable-content\\\" #content>\\n      <ng-content></ng-content>\\n    </div>\\n  \",\r\n                host: {\r\n                    '[class.horizontal]': \"horizontal\",\r\n                    '[class.vertical]': \"!horizontal\",\r\n                    '[class.selfScroll]': \"!parentScroll\"\r\n                },\r\n                styles: [\"\\n    :host {\\n      position: relative;\\n\\t  display: block;\\n      -webkit-overflow-scrolling: touch;\\n    }\\n\\t\\n\\t:host.horizontal.selfScroll {\\n      overflow-y: visible;\\n      overflow-x: auto;\\n\\t}\\n\\t:host.vertical.selfScroll {\\n      overflow-y: auto;\\n      overflow-x: visible;\\n\\t}\\n\\t\\n    .scrollable-content {\\n      top: 0;\\n      left: 0;\\n      width: 100%;\\n      height: 100%;\\n      max-width: 100vw;\\n      max-height: 100vh;\\n      position: absolute;\\n    }\\n\\n\\t.scrollable-content ::ng-deep > * {\\n\\t\\tbox-sizing: border-box;\\n\\t}\\n\\t\\n\\t:host.horizontal {\\n\\t\\twhite-space: nowrap;\\n\\t}\\n\\t\\n\\t:host.horizontal .scrollable-content {\\n\\t\\tdisplay: flex;\\n\\t}\\n\\t\\n\\t:host.horizontal .scrollable-content ::ng-deep > * {\\n\\t\\tflex-shrink: 0;\\n\\t\\tflex-grow: 0;\\n\\t\\twhite-space: initial;\\n\\t}\\n\\t\\n    .total-padding {\\n      width: 1px;\\n      opacity: 0;\\n    }\\n    \\n    :host.horizontal .total-padding {\\n      height: 100%;\\n    }\\n  \"]\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nVirtualScrollerComponent.ctorParameters = function () { return [\r\n    { type: core_1.ElementRef, },\r\n    { type: core_1.Renderer2, },\r\n    { type: core_1.NgZone, },\r\n    { type: core_1.ChangeDetectorRef, },\r\n    { type: Object, decorators: [{ type: core_1.Inject, args: [core_2.PLATFORM_ID,] },] },\r\n    { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: ['virtualScroller.scrollThrottlingTime',] },] },\r\n    { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: ['virtualScroller.scrollDebounceTime',] },] },\r\n    { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: ['virtualScroller.scrollAnimationTime',] },] },\r\n    { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: ['virtualScroller.scrollbarWidth',] },] },\r\n    { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: ['virtualScroller.scrollbarHeight',] },] },\r\n    { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: ['virtualScroller.checkResizeInterval',] },] },\r\n    { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: ['virtualScroller.resizeBypassRefreshThreshold',] },] },\r\n    { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: ['virtualScroller.modifyOverflowStyleOfParentScroll',] },] },\r\n    { type: undefined, decorators: [{ type: core_1.Optional }, { type: core_1.Inject, args: ['virtualScroller.stripedTable',] },] },\r\n]; };\r\nVirtualScrollerComponent.propDecorators = {\r\n    'executeRefreshOutsideAngularZone': [{ type: core_1.Input },],\r\n    'enableUnequalChildrenSizes': [{ type: core_1.Input },],\r\n    'useMarginInsteadOfTranslate': [{ type: core_1.Input },],\r\n    'modifyOverflowStyleOfParentScroll': [{ type: core_1.Input },],\r\n    'stripedTable': [{ type: core_1.Input },],\r\n    'scrollbarWidth': [{ type: core_1.Input },],\r\n    'scrollbarHeight': [{ type: core_1.Input },],\r\n    'childWidth': [{ type: core_1.Input },],\r\n    'childHeight': [{ type: core_1.Input },],\r\n    'ssrChildWidth': [{ type: core_1.Input },],\r\n    'ssrChildHeight': [{ type: core_1.Input },],\r\n    'ssrViewportWidth': [{ type: core_1.Input },],\r\n    'ssrViewportHeight': [{ type: core_1.Input },],\r\n    'bufferAmount': [{ type: core_1.Input },],\r\n    'scrollAnimationTime': [{ type: core_1.Input },],\r\n    'resizeBypassRefreshThreshold': [{ type: core_1.Input },],\r\n    'scrollThrottlingTime': [{ type: core_1.Input },],\r\n    'scrollDebounceTime': [{ type: core_1.Input },],\r\n    'checkResizeInterval': [{ type: core_1.Input },],\r\n    'items': [{ type: core_1.Input },],\r\n    'compareItems': [{ type: core_1.Input },],\r\n    'horizontal': [{ type: core_1.Input },],\r\n    'parentScroll': [{ type: core_1.Input },],\r\n    'update': [{ type: core_1.Output },],\r\n    'vsUpdate': [{ type: core_1.Output },],\r\n    'change': [{ type: core_1.Output },],\r\n    'vsChange': [{ type: core_1.Output },],\r\n    'start': [{ type: core_1.Output },],\r\n    'vsStart': [{ type: core_1.Output },],\r\n    'end': [{ type: core_1.Output },],\r\n    'vsEnd': [{ type: core_1.Output },],\r\n    'contentElementRef': [{ type: core_1.ViewChild, args: ['content', { read: core_1.ElementRef },] },],\r\n    'invisiblePaddingElementRef': [{ type: core_1.ViewChild, args: ['invisiblePadding', { read: core_1.ElementRef },] },],\r\n    'headerElementRef': [{ type: core_1.ContentChild, args: ['header', { read: core_1.ElementRef },] },],\r\n    'containerElementRef': [{ type: core_1.ContentChild, args: ['container', { read: core_1.ElementRef },] },],\r\n};\r\nexports.VirtualScrollerComponent = VirtualScrollerComponent;\r\nvar VirtualScrollerModule = (function () {\r\n    function VirtualScrollerModule() {\r\n    }\r\n    return VirtualScrollerModule;\r\n}());\r\nVirtualScrollerModule.decorators = [\r\n    { type: core_1.NgModule, args: [{\r\n                exports: [VirtualScrollerComponent],\r\n                declarations: [VirtualScrollerComponent],\r\n                imports: [common_2.CommonModule]\r\n            },] },\r\n];\r\n/** @nocollapse */\r\nVirtualScrollerModule.ctorParameters = function () { return []; };\r\nexports.VirtualScrollerModule = VirtualScrollerModule;\r\n//# sourceMappingURL=virtual-scroller.js.map"],"sourceRoot":""}